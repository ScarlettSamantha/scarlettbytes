"""
This type stub file was generated by pyright.
"""

from pymemcache.client.base import Client

logger = ...
class HashClient:
    """
    A client for communicating with a cluster of memcached servers
    """
    client_class = Client
    def __init__(self, servers, hasher=..., serde=..., serializer=..., deserializer=..., connect_timeout=..., timeout=..., no_delay=..., socket_module=..., socket_keepalive=..., key_prefix=..., max_pool_size=..., pool_idle_timeout=..., lock_generator=..., retry_attempts=..., retry_timeout=..., dead_timeout=..., use_pooling=..., ignore_exc=..., allow_unicode_keys=..., default_noreply=..., encoding=..., tls_context=...) -> None:
        """
        Constructor.

        Args:
          servers: list() of tuple(hostname, port) or string containing a UNIX
                   socket path.
          hasher: optional class three functions ``get_node``, ``add_node``,
                  and ``remove_node``
                  defaults to Rendezvous (HRW) hash.

          use_pooling: use py:class:`.PooledClient` as the default underlying
                       class. ``max_pool_size`` and ``lock_generator`` can
                       be used with this. default: False

          retry_attempts: Amount of times a client should be tried before it
                          is marked dead and removed from the pool.
          retry_timeout (float): Time in seconds that should pass between retry
                                 attempts.
          dead_timeout (float): Time in seconds before attempting to add a node
                                back in the pool.
          encoding: optional str, controls data encoding (defaults to 'ascii').

        Further arguments are interpreted as for :py:class:`.Client`
        constructor.
        """
        ...
    
    def add_server(self, server, port=...) -> None:
        ...
    
    def remove_server(self, server, port=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    disconnect_all = ...
    def set(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def get(self, key, default=..., **kwargs): # -> None:
        ...
    
    def incr(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def decr(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def set_many(self, values, *args, **kwargs): # -> list[Any]:
        ...
    
    set_multi = ...
    def get_many(self, keys, gets=..., *args, **kwargs): # -> dict[Any, Any]:
        ...
    
    get_multi = ...
    def gets(self, key, *args, **kwargs): # -> None:
        ...
    
    def gets_many(self, keys, *args, **kwargs): # -> dict[Any, Any]:
        ...
    
    gets_multi = ...
    def add(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def prepend(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def append(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def delete(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def delete_many(self, keys, *args, **kwargs) -> bool:
        ...
    
    delete_multi = ...
    def cas(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def replace(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def touch(self, key, *args, **kwargs): # -> Literal[False]:
        ...
    
    def flush_all(self, *args, **kwargs) -> None:
        ...
    
    def quit(self) -> None:
        ...
    


